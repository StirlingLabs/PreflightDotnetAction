inputs:
  solution:
    description: Solution file name
    type: string
    required: false
  library:
    description: Is this project a library or executable?
    type: boolean
    default: true
  strict:
    description: Strict adherence to requirements
    type: boolean
    default: true
  verbose:
    description: Verbose output or terse
    type: boolean
    default: true
outputs:
  continue:
    description: Successfully passed all preflight checks
    value: ${{ steps.create.outputs.success }}

runs:
  using: 'composite'
  steps:
  - name: Debugging
    if: false
    shell: bash
    env:
      GITHUB_CONTEXT: ${{ toJSON(github) }}
    run: |
      main() {
        echo -e "\n$GITHUB_CONTEXT"
      }
      main "$@" ; exit

  - name: Set Values
    id: values
    shell: bash
    env:
      packageOutputPath: "../artifacts"
      projectExtension: ".csproj"
      solution: ${{ inputs.solution }}
      strict: ${{ inputs.strict }}
      verbose: ${{ inputs.verbose }}
    run: |
      main() {
        echo "packageOutputPath=$packageOutputPath" >> "$GITHUB_OUTPUT"
        echo "projectExtension=$projectExtension" >> "$GITHUB_OUTPUT"

        # Find Solution
        echo "Finding solution, initially set to: \'$solution\'"
        if [[ ! -f "$solution" ]] ; then
          [[ "$solution" != *".sln" ]] && solution="${solution}.sln"
          if [[ ! -f "$solution" ]] ; then
            echo "Searching for Solution..."
            solution="$(find . -name '*.sln')" || fail "Problem finding solution: $solution"
            count="$(echo "$solution" | grep ".sln" --count --only-matching)" || fail "Problem counting solutions: $count"
            if [[ "$count" -ne 1 ]] ; then
              fail "${count} solutions found!\nIf a single solution file is not in the root directory, specify _one_ with the \`solution\` input.\n$solution"
            fi
          fi
        fi
        echo "Solution found: \`$solution\`"
        echo "solution=$solution" >> "$GITHUB_OUTPUT"

        echo "### Processing $solution" >> "$GITHUB_STEP_SUMMARY"
        echo "Strict Mode: $strict, Verbose: $verbose" >> "$GITHUB_STEP_SUMMARY"

        strict="${strict,,}"
        echo "strict=$strict" >> "$GITHUB_OUTPUT"

        verbose="${verbose,,}"
        echo "verbose=$verbose" >> "$GITHUB_OUTPUT"

        echo "${heading}" 
      }

      function fail {
        printf '%s\n' "‼️ Error: $1" >&2 ## Send message to stderr.
        echo -e "\n### ❌ Error\n#### $1" >> "$GITHUB_STEP_SUMMARY"
        exit "${2-1}" ## Exit code specified by $2, or 1 by default.
      }
      main "$@" ; exit

  - name: Version.Net Existance
    id: version-existance
    shell: bash
    env:
      filename: Version.proj
      submoduleDir: StirlingLabs.Version
      strict: ${{ steps.values.outputs.strict }}
      verbose: ${{ steps.values.outputs.verbose }}
    run: |
      main() {
        echo "Checking for Version.Net submodule in $submoduleDir"
        if [[ ! -d "$submoduleDir" ]] ; then
          ls -la
          msg="Install [https://github.com/StirlingLabs/Version.Net](Version.Net) as specified in the README.md"
          [[ "$strict" == "true" ]] && fail "Version.Net not found at $submoduleDir. $msg"
        fi

        echo "Checking for Version.Net project file"
        if [[ -f "$filename" ]] ; then
          echo "projFile=$(realpath "$filename")" >> "$GITHUB_OUTPUT"
          echo "✅ found Version.Net" >> "$GITHUB_STEP_SUMMARY"
        else
          msg="Please create $filename as per [readme](https://github.com/StirlingLabs/Version.Net#how-do-i-install-it)"
          fail "$filename not found. $msg"
        fi
      }

      function fail {
        printf '%s\n' "‼️ Error: $1" >&2 ## Send message to stderr.
        echo -e "\n### ❌ Error\n#### $1" >> "$GITHUB_STEP_SUMMARY"
        exit "${2-1}" ## Exit code specified by $2, or 1 by default.
      }
      main "$@" ; exit

  - name: Install Tools
    id: install
    shell: bash
    env:
      emptyDir: 'this_is_an_empty_dir__but_it_wont_be_empty_long' # Appologies to Nick Cave
      strict: true
      verbose: ${{ steps.values.outputs.verbose }}
    run: |
      main() {
        echo "Installing tools"
        install_csprojcli
        echo "✅ Tools installed" >> "$GITHUB_STEP_SUMMARY"
      }

      function install_csprojcli {
        echo "Installing csprojcli"
        # Install csprojcli -- which unfortunately cannot be done in a dir with multiple projects below it
        [[ -f "$emptyDir" ]] && fail "There is a file called $emptyDir please remove it!!"
        mkdir -p "$emptyDir" || fail "Could not create $emptyDir"
        cd "$emptyDir" || fail "Could not change into $emptyDir"
        dotnet tool install -g csprojcli || fail "Problem installing csprojcli."
        cd ..
        rmdir "$emptyDir" || fail "Could not remove $emptyDir"
        if csprojcli="$(which csprojcli)" ; then
          echo "csprojcli installed in $csprojcli"
        fi
      }

      function fail {
        printf '%s\n' "‼️ Error: $1" >&2 ## Send message to stderr.
        echo -e "\n### ❌ Error\n#### $1" >> "$GITHUB_STEP_SUMMARY"
        exit "${2-1}" ## Exit code specified by $2, or 1 by default.
      }

      main "$@" ; exit

  - name: Interrogate Solution
    id: solution
    shell: bash
    env:
      solution: ${{ steps.values.outputs.solution }}
      projectExtension: ${{ steps.values.outputs.projectExtension }}
      strict: ${{ steps.values.outputs.strict }}
      verbose: ${{ steps.values.outputs.verbose }}
    run: |
      main() {
        # Interrogate Solution
        echo "Getting list of projects from $solution"
        if projects="$(dotnet sln "$solution" list | sed -e 1,2d)" ; then
          echo "Solution interrogated"
        else
          fail "Problem interrogating solution: $projects"
        fi

        [[ "$projects" == "" ]] && fail "No projects in solution."
        [[ "${projects,,}" != *"$projectExtension" ]] && fail "No C# projects found!"
        echo "Total of $(echo "$projects" | grep -c "$projectExtension") projects found."

        readarray -t projectArray <<< "$projects"

        # Convert to JSON
        err="Problem converting projects to JSON: "
        projectsJSON="$(jq --compact-output --null-input '$ARGS.positional' --args -- "${projectArray[@]}")" || fail "$err: $projectsJSON"
        err="Problem processing JSON: "
        testProjectsJSON=$(echo "$projectsJSON" | jq -c 'map(select(contains(".Tests.csproj")))') || fail "$err: $testProjectsJSON"
        realProjectsJSON=$(echo "$projectsJSON" | jq -c 'map(select(contains(".Tests.csproj") | not))') || fail "$err: $realProjectsJSON"
        testProjectCount=$(echo "$testProjectsJSON" | jq -r 'length') || fail "$err: $testProjectCount"
        realProjectCount=$(echo "$realProjectsJSON" | jq -r 'length') || fail "$err: $realProjectCount"
        echo "$testProjectCount test project(s) found."
        echo "$realProjectCount prod project(s) found."
        err="Test projects should be named with the suffix \`.Tests\`"
        [[ $testProjectCount -gt 0 ]] || fail "$testProjectCount test projects found:\n- $err\n- Projects \`$projects\`"
        [[ $realProjectCount -gt 0 ]] || fail "$realProjectCount prod projects found:\n- $err\n- Projects \`$projects\`"

        # Summarise
        #shellcheck disable=SC2129
        echo "### Projects identified" >> "$GITHUB_STEP_SUMMARY"
        echo "| Status | Name | Path |" >> "$GITHUB_STEP_SUMMARY"
        echo "|---|---|---|" >> "$GITHUB_STEP_SUMMARY"
        problem="false"
        for project in "${projectArray[@]}" ; do
          if [[ -f "$project" ]] ; then
            start="| 🟢 | $(projectName "$project")"
          else
            start="| 🔴 | NOT FOUND"
            problem="true"
          fi
          echo "$start | $project |" >> "$GITHUB_STEP_SUMMARY"
        done
        echo "|---|---|---|" >> "$GITHUB_STEP_SUMMARY"
        [[ "$problem" == "true" ]] && fail "Some projects were not found."
        #shellcheck disable=SC2129
        echo "projectsJSON=$projectsJSON" >> "$GITHUB_OUTPUT"
        echo "testProjectsJSON=$testProjectsJSON" >> "$GITHUB_OUTPUT"
        echo "realProjectsJSON=$realProjectsJSON" >> "$GITHUB_OUTPUT"
        echo "testProjectCount=$testProjectCount" >> "$GITHUB_OUTPUT"
        echo "realProjectCount=$realProjectCount" >> "$GITHUB_OUTPUT"
      }

      function projectName {
        local fullPath="$1" ; local ext="${1##*.}" ; local name
        if name="$(basename "$fullPath" ".${ext}")" ; then # Remove extension and path to return the project name
          echo "$name"
        else
          fail "Internal Error:\n- Could not get project name from $fullPath\n- $name"
        fi
      }

      function fail {
        printf '%s\n' "‼️ Error: $1" >&2 ## Send message to stderr.
        echo -e "\n### ❌ Error\n#### $1" >> "$GITHUB_STEP_SUMMARY"
        exit "${2-1}" ## Exit code specified by $2, or 1 by default.
      }
      main "$@" ; exit

  - name: Version.Proj Referenced
    shell: bash
    id: version-reference
    if: ${{ steps.version-existence.outputs.projFile != '' }}
    env:
      versionProj: ${{ steps.version-existence.outputs.projFile }}
      realProjects: ${{ fromJSON(steps.solution.outputs.realProjectsJSON) }}
      realProjectCount: ${{ steps.solution.outputs.realProjectCount }}
      strict: ${{ steps.values.outputs.strict }}
      verbose: ${{ steps.values.outputs.verbose }}
    run: |
      main() {
        echo "Checking that Version.proj is referenced by production projects"
        echo -e "### Version.Net References\n|---|---|---|" >> "$GITHUB_STEP_SUMMARY"
        count=0
        problemMsg="Please see the [Version.Net documentation](https://github.com/StirlingLabs/Version.Net) for how to import it."
        for project in "${realProjects[@]}" ; do
          relativePath="$(realpath --relative-to="$project" "$versionProj")"
          echo "$project Version.proj -> $relativePath"
          if [[ "$(doesProjectImport "$project")" == "true" ]] ; then
            echo "$project imports something"
            imports="$(getProjectImports "$project")"
            echo "- specifically \`$imports\`"
            i=0
            for import in "${imports[@]}" ; do
              if [[ "$import" -ef "$relativePath" ]] ; then # -ef compares effective paths
                i=$((i+1))
                echo "${i}. Reference to Version.Net found in $project"
              fi
            done
            [[ "$i" -eq 0 ]] && printBad "$project" "No Version.Net references found. $problemMsg"
            [[ "$i" -eq 1 ]] && printGood "$project" && count=$((count+1))
            [[ "$i" -gt 1 ]] && printOkay "$project" "Too many ($i) Version.Net references found, should only be 1."
          else
            printBad "$project" "Does not import anything. $problemMsg"
          fi
        done
        echo "|---|---|---|" >> "$GITHUB_STEP_SUMMARY"
        if [[ "$count" -eq "$realProjectCount" ]] ; then
          echo "found=true" >> "$GITHUB_OUTPUT"
        else
          echo "Version.Net not referenced by all projects ($count/$realProjectCount)." >&2
          [[ "$strict" == "false" ]] && fail "Version.Net not referenced by all projects ($count/$realProjectCount)."
        fi
      }

      function printGood {
        [[ "$verbose" != "true" ]] && echo -e "| ✅ | $1 | |" >> "$GITHUB_STEP_SUMMARY"
      }

      function printOkay {
        echo -e "| ⚠️ | $1 | $2 |" >> "$GITHUB_STEP_SUMMARY"
      }

      function printBad {
        printf '%s\n' "‼️ Error: $1" >&2 ## Send message to stderr.
        echo -e "| ❌ | $1 | $2 |" >> "$GITHUB_STEP_SUMMARY"
      }

      function getProjectImports {
        local projectFile="$1" ; local result ; local value
        if value=$(csprojcli nodevalue.get -p "$projectFile" -g "ImportGroup" -n "Import" -a "Project") ; then
          echo "$value"
        else
          fail "Internal Error:\n- Problem while looking for Imports in $(projectName "$projectFile")\n- $value"
        fi
      }

      function doesProjectImport {
        local projectFile="$1" ; local result ; local value
        result="false"
        if value="$(csprojcli -p "$projectFile" -g "ImportGroup" -n "Import" -a "Project")" ; then
          result="${value,,}"
        else
          fail "Internal Error:\n- Problem while looking for Imports in $(projectName "$projectFile")\n- $value"
        fi
        echo "$result"
      }

      function projectName {
        local fullPath="$1" ; local ext="${1##*.}" ; local name
        if name="$(basename "$fullPath" ".${ext}")" ; then # Remove extension and path to return the project name
          echo "$name"
        else
          fail "Internal Error:\n- Could not get project name from $fullPath\n- $name"
        fi
      }

      function fail {
        printf '%s\n' "‼️ Error: $1" >&2 ## Send message to stderr.
        echo -e "\n### ❌ Error\n#### $1" >> "$GITHUB_STEP_SUMMARY"
        exit "${2-1}" ## Exit code specified by $2, or 1 by default.
      }
      main "$@" ; exit

  - name: Version.Proj Metadata
    id: metadata
    shell: bash
    if: steps.version-reference.outputs.found == 'true' 
    env:
      versionProj: ${{ steps.version-existence.outputs.projFile }}
      homepage: ${{ inputs.homepage }}
      gitUrl: ${{ inputs.gitUrl }}
      strict: ${{ steps.values.outputs.strict }}
      verbose: ${{ steps.values.outputs.verbose }}
    run: |
      main() {
        echo "Checking for correct values in $versionProj"
        echo -e "### Version.Net Metadata\n|---|---|---|" >> "$GITHUB_STEP_SUMMARY"
        problem=""
        #          NodeName  TestType  TestValue      Error Message
        printContains "Authors" "Stirling Labs Team"  "Credit others but always report that we create the NuPkg, so are at least one of the authors."
        printContains "Owners" "Stirling Labs"        "Credit others as authors but always report that we own the NuPkg."
        printEquality "Company" "Stirling Labs"       "The company is Stirling Labs"
        printEquality "RepositoryType" "git"          "Is git, it's always git."
        printEquality "RepositoryUrl" "$gitUrl"       "Should be this repo $gitUrl"
        printEquality "PackageProjectUrl" "$homepage" "Should be our GitHub page for the project; $homepage"
        printEquality "GitCommitsIgnoreMerges" "true" "GitCommitsIgnoreMerges should be true"

        nodeGitDefaultBranchValue="$(getNodeValue "GitDefaultBranch")"
        if [[ "$nodeGitDefaultBranchValue" == "main" ]] ; then
          printGood "GitDefaultBranch"
        else
          if [[ "$nodeGitDefaultBranchValue" == "master" ]] ; then
            printOkay "GitDefaultBranch" "Default branch should be \`main\` unless forced by an upstream repo."
          else
            printBad "GitDefaultBranch" "Should be \`main\` (can be \`master\` if forced by upstream repo)."
            echo -e "Problem: GitDefaultBranch should not be \`$nodeGitDefaultBranchValue\`" >&2
          fi
        fi
        
        for node in "PackageIcon" "PackageReadmeFile" "PackageLicenseFile" ; do
          value=$(getNodeValue "$node")
          if [[ -f "$value" ]] ; then
            printGood "$node"
          else
            printOkay "$node" "File not found at $value as indicated. Check it's copied into place by the csproj."
          fi
        done
        echo "|---|---|---|" >> "$GITHUB_STEP_SUMMARY"
        if [[ "$problem" == "true" ]] ; then
          [[ "$strict" == "true" ]] && fail "Version.Net metadata is not correct."
          [[ "$strict" == "false" ]] && echo "### ⚠️ Note: Version.Net metadata is not correct." >> "$GITHUB_STEP_SUMMARY"
        fi
      }

      function printGood {
        [[ "$verbose" != "true" ]] && echo -e "| ✅ | $1 | |" >> "$GITHUB_STEP_SUMMARY"
      }

      function printOkay {
        echo -e "| ⚠️ | $1 | $2 |" >> "$GITHUB_STEP_SUMMARY"
      }

      function printBad {
        printf '%s\n' "‼️ Error: $1" >&2 ## Send message to stderr.
        echo -e "| ❌ | $1 | $2 |" >> "$GITHUB_STEP_SUMMARY"
        problem="true"
      }

      function printEquality {
        local nodeName="$1" ; local expectedValue="$2" ; local errorMessage="$3" ; local result
        result="$(getNodeValue "$nodeName")"
        if [[ "$(validateSingleNodeValue "$result" "$nodeName")" == "true" ]] \
            && [[ "$result" == "$expectedValue" ]] ; then
          printGood "$nodeName"
        else
          printBad "$nodeName" "$errorMessage"
          problem="true"
        fi
      }

      function printContains {
        local nodeName="$1" ; local expectedValue="$2" ; local errorMessage="$3" ; local result
        result="$(getNodeValue "$nodeName")"
        if [[ "$(validateSingleNodeValue "$result" "$nodeName")" == "true" ]] \
            && [[ "$result" == *"$expectedValue"* ]] ; then
          printGood "$nodeName"
        else
          printBad "$nodeName" "$errorMessage"
          problem="true"
        fi
      }

      function nodeExists {
        local projectFile="$versionProj" ; local nodeName="$1" ; local existence
        if existence=$(csprojcli nodevalue.exists -p "$projectFile" -g PropertyGroup -n "$nodeName") ; then
          echo "${existence,,}"
        else
          fail "Internal problem; csprojcli failed: $existence"
        fi
      }

      function getNodeValue {
        local projectFile="$versionProj" ; local nodeName="$1" ; local value
        if [[ "$(nodeExists "$nodeName")" == "true" ]] ; then
          if value=$(csprojcli nodevalue.get -p "$projectFile" -g PropertyGroup -n "$nodeName") ; then
            echo "$value"
          else
            fail "Internal problem; csprojcli failed: $value"
          fi
        fi
      }

      function validateSingleNodeValue {
        local nodeValue="$1" ; local nodeName="$2" ; local result
        result="false"
        if [[ "$(wc -l <<< "$nodeValue")" -gt 1 ]] ; then
          echo "Multiple values found in $nodeName, should only be one value but got $nodeValue" >&2
          printBad "$nodeName" "Multiple values found, should only be one value."
        else
          result="true"
        fi
        echo "$result"
      }

      function fail {
        printf '%s\n' "‼️ Error: $1" >&2 ## Send message to stderr.
        echo -e "### ❌ Error ❌\n$1" >> "$GITHUB_STEP_SUMMARY"
        exit "${2-1}" ## Exit code specified by $2, or 1 by default.
      }
      main "$@" ; exit

  - name: Metadata Shadows
    id: metadata-shadowing
    shell: bash
    if: steps.version-reference.outputs.found == 'true'
    env:
      versionProj: ${{ steps.version-existence.outputs.projFile }}
      realProjects: ${{ fromJSON(steps.solution.outputs.realProjectsJSON) }}
      strict: ${{ steps.values.outputs.strict }}
      verbose: ${{ steps.values.outputs.verbose }}
    run: |
      # Check that no csproj files override settings from Version.proj
      # This should be kept in sync with the list of properties in Version.proj
      main() {
        problem="false"
        for project in "${realProjects[@]}" ; do
          count=$((count+1))
          echo "${count}. Checking for metadata shadowing in $project"
          error=""
          for node in "Authors" "Owners" "Company" "RepositoryType" "RepositoryUrl" "PackageProjectUrl" "GitDefaultBranch" "GitCommitsIgnoreMerges" ; do
            if [[ "$(nodeExists "$project" "$node")" == "true" ]] ; then
              error="$error\n\t- $node"
            fi
          done
          if [[ "$error" == "" ]] ; then
            good "$project"
          else
            bad "$project attempts to override values that should only be set in $versionProj:\n$error"
            problem="true"
          fi
        done
        if [[ "$problem" == "true" ]] && [[ "$strict" == "true" ]] ; then
          fail "Metadata shadowing detected.  See above for details."
        fi
      }

      function good {
        [[ "$verbose" != "true" ]] && echo "- ✅ $1" >> "$GITHUB_STEP_SUMMARY"
      }

      function bad {
        printf '%s\n' "‼️ Error: $1" >&2 ## Send message to stderr.
        echo "- ❌ $1" >> "$GITHUB_STEP_SUMMARY"
      }

      function fail {
        printf '%s\n' "‼️ Error: $1" >&2 ## Send message to stderr.
        echo -e "### ❌ Error ❌\n$1" >> "$GITHUB_STEP_SUMMARY"
        exit "${2-1}" ## Exit code specified by $2, or 1 by default.
      }

      function nodeExists {
        local nodeName="$2" ; local filename="$1" ; local result ; local existence
        result="false"
        if existence=$(csprojcli nodevalue.exists -p "$filename" -g PropertyGroup -n "$nodeName") ; then
          [[ "$existence" == "True" ]] && result="true"
        else
          fail "Internal Error\nProblem checking for $nodeName in $filename\n$existence"
        fi
        echo "$result"
      }
      main "$@" ; exit

  - name: Logging
    id: logging
    shell: bash
    env:
      projectExtension: ${{ steps.values.outputs.projectExtension }}
      testProjects: ${{ fromJSON(steps.solution.outputs.testProjectsJson) }}
      realProjects: ${{ fromJSON(steps.solution.outputs.realProjectsJson) }}
      strict: ${{ steps.values.outputs.strict }}
      verbose: ${{ steps.values.outputs.verbose }}
    run: | 
      main() {
        failure="false" ; inProject=""
        for project in "${testProjects[@]}" ; do
          inProject="in $(projectName "$project")"
          echo "Test project: $project"

          # All test projects should have GitHubActionsTestLogger & coverlet.collector
          problem="false" ; msg=""
          for package in "GitHubActionsTestLogger" "coverlet.collector" ; do
            if [[ "$(packageReference "$project" "$package")" != "true" ]] ; then
              problem="true"
              msg="$msg\n\`\`\`shell\n> dotnet add \"${project}\" package $package\n\`\`\`"
              bad "$package not found" "$inProject" "$msg"
            fi
          done
          if [[ "$problem" == "false" ]] ; then
            good "Required logging packages found" "$inProject"
          else
            bad "Required logging packages not found" "$inProject" "To install:\n$msg"
            [[ "$strict" == "true" ]] && failure="true"
          fi

          # Test projects should NOT have coverlet.msbuild
          package="coverlet.msbuild"
          if [[ "$(packageReference "$project" "$package")" == "true" ]] ; then
            msg="There are [known issues](https://github.com/coverlet-coverage/coverlet/blob/master/Documentation/KnownIssues.md#1-vstest-stops-process-execution-earlydotnet-test)"
            msg="$msg with this package, please remove it to avoid problems with the build process."
            bad "$package found" "$inProject" "$msg"
            failure="true"
          else
            good "$package not found" "$inProject"
          fi
        done

        # Production projects should NOT have test logging
        problem="false"
        for project in "${realProjects[@]}" ; do
          inProject="in $(projectName "$project")"
          for package in "coverlet.collector" "coverlet.msbuild" "GitHubActionsTestLogger" ; do
            if [[ "$(packageReferenceIsValue "$project" "$package")" == "true" ]] ; then
              problem="true"
              bad "$package found in production project" "$inProject" "$package should only be used in test projects."
            fi
          done
        done
        if [[ "$problem" == "false" ]] ; then
          good "Test logging packages not found" "$inProject"
        else
          [[ "$strict" == "true" ]] && failure="true"
        fi

        [[ "$failure" == "true" ]] && fail "One or more serious problems found with logging."
      }

      function good {
        echo -e "$1 $2"
        [[ "$verbose" != "true" ]] && echo -e "- ✅ $1 $2" >> "$GITHUB_STEP_SUMMARY"
      }

      function bad {
        echo -e "❌ $1 $2 ❌\n$3" >&2
        echo -e "- ❌ $1 $2" >> "$GITHUB_STEP_SUMMARY"
      }

      function fail {
        printf '%s\n' "‼️ Error: $1" >&2 ## Send message to stderr.
        echo -e "### ❌ Error ❌\n- $1" >> "$GITHUB_STEP_SUMMARY"
        exit "${2-1}" ## Exit code specified by $2, or 1 by default.
      }

      function projectName {
        local fullPath="$1" ; local ext="${1##*.}" ; local name
        if name="$(basename "$fullPath" ".${ext}")" ; then # Remove extension and path to return the project name
          echo "$name"
        else
          fail "Internal Error:\n- Could not get project name from $fullPath\n- $name"
        fi
      }

      function packageReferenceIsValue {
        local projectFile="$1" ; local value="$2" ; local result ; local valueExists
        result="false"
        if valueExists=$(csprojcli attributevalue.exists -p "$projectFile" -g "ItemGroup" -n "PackageReference" -a "Include" -v "$value") ; then
          if [[ "$valueExists" == "True" ]] ; then
            result="true"
          fi
        else
          echo "$value not found as PackageReference in $projectFile." >&2
        fi
        return "$result"
      }
      main "$@" ; exit

  - name: csproj Build
    id: build
    shell: bash
    env:
      testProjects: ${{ fromJSON(steps.solution.outputs.testProjectsJSON) }}
      realProjects: ${{ fromJSON(steps.solution.outputs.realProjectsJSON) }}
      packageOutputPath: ${{ steps.values.outputs.packageOutputPath }}
      isLibrary: ${{ inputs.library }}
      strict: ${{ steps.values.outputs.strict }}
      verbose: ${{ steps.values.outputs.verbose }}
    run: | 
      # Process C# projects to ensure PackageOutputPath & GeneratePackageOnBuild is set correctly
      main() {
        isLibrary="${isLibrary,,}" ; error="false"
        echo -e "### Build details\n|---|---|---|---|" >> "$GITHUB_STEP_SUMMARY"
        
        for project in "${realProjects[@]}" ; do

          # PackageOutputPath
          package="PackageOutputPath"
          if [[ $(nodeHasValue "$project" "$package" "$packageOutputPath") == "true" ]] ; then
            good "$project" "$package"
          else
            msg="\`$package\` should be set to \`$packageOutputPath\`."
            detail="To do this, add the following excerpt to $project:\n$(propertyGroupExcerpt "$package" "$packageOutputPath")"
            bad "$project" "$package" "$msg" "$detail"
            error="true"
          fi

          # GeneratePackageOnBuild
          package="GeneratePackageOnBuild"
          msg="Lbrary projects have \`$package\` set to \`$isLibrary\`, while executable projects should not have it set, or set it to false."
          detail="To set:\n\`\`\`xml\n<PropertyGroup>\n  <$package>$isLibrary</$package>\n</PropertyGroup>\n\`\`\`\n"
          if [[ $(nodeExists "$project" "$package") == "true" ]] ; then
            if [[ $(nodeHasValue "$project" "$package" "$isLibrary") == "true" ]] ; then
              good "$project" "$package"
            else
              bad "$project" "$package" "$msg" "$detail"
              error="true"
            fi
          else
            if [[ "$isLibrary" == "false" ]] ; then
              good "$project" "$package"
            else
              bad "$project" "$package" "$msg" "$detail"
              error="true"
            fi
          fi

        done

        echo "|---|---|---|---|" >> "$GITHUB_STEP_SUMMARY"
        if [[ "error" == "true" ]] ; then
          if [[ "$strict" == "true" ]] ; then
            fail "One or more problems found with logging, check log for."
          else
            echo "## Errors occurred, view log for details." >> "$GITHUB_STEP_SUMMARY"
          fi
        fi
      }

      function printGood {
        local proj="$(projectName "$1")" ; local package="$2"
        [[ "$verbose" != "true" ]] && echo -e "| ✅ | $proj | $package |  |" >> "$GITHUB_STEP_SUMMARY"
      }

      function printOkay {
        local proj="$(projectName "$1")" ; local package="$2" ; local msg="$3" ; local detail="$4"
        echo "| ⚠️ | $proj | $2 | $3 |" >> "$GITHUB_STEP_SUMMARY"
        echo -e "⚠️ $1 $2 $3 $4" >&2
      }

      function printBad {
        local proj="$(projectName "$1")" ; local package="$2" ; local msg="$3" ; local detail="$4"
        echo "| ❌ | $proj | $2 | $3 |" >> "$GITHUB_STEP_SUMMARY"
        echo -e "❌ $1 $2 $3 $4" >&2
      }

      function projectName {
        local fullPath="$1" ; local ext="${1##*.}" ; local name
        if name="$(basename "$fullPath" ".${ext}")" ; then # Remove extension and path to return the project name
          echo "$name"
        else
          fail "Internal Error:\n- Could not get project name from $fullPath\n- $name"
        fi
      }

      function propertyGroupExcerpt {
        local node="$1" ; local value="$2"
        #shellcheck disable=SC2028
        echo "\`\`\`xml\n<PropertyGroup>\n\t<${node}>$value</${node}>\n</PropertyGroup>\n\`\`\`"
      }

      function nodeHasValue {
        local projectFile="$1" ; local nodeName="$2" ; local value="$3" ; local result ; local nodeValue
        result="false"
        if [[ "$(nodeExists "$projectFile" "$nodeName")" == "true" ]] ; then
          if nodeValue="$(csprojcli nodevalue.get -p "$projectFile" -g "PropertyGroup" -n "$nodeName")" ; then
            if [[ "$nodeValue" == "$value" ]] ; then
              result="true"
            else
              echo "Node $nodeName in $projectFile does not have the expected value $value but is $nodeValue." >&2
            fi
          else
            fail "Getting value of Node $nodeName in $projectFile and encountered an error:\n$nodeValue"
          fi
        fi
        echo "$result"
      }

      function nodeExists {
        local projectFile="$1" ; local nodeName="$2" ; local result ; local existence
        result="false"
        if existence="$(csprojcli node.exists -p "$projectFile" -g "PropertyGroup" -n "$nodeName")" ; then
          if [[ "$existence" == "True" ]] ; then
            result="true"
          else
            echo "Node $nodeName does not exist in $projectFile." >&2
          fi
          echo "$result"
        else
          fail "Internal error\nTesting if Node $nodeName exists in $projectFile and encountered an error:\n$existence"
        fi
      }

      function fail {
        printf '%s\n' "‼️ Error: $1" >&2 ## Send message to stderr.
        echo -e "\n### ❌ Error\n#### $1" >> "$GITHUB_STEP_SUMMARY"
        exit "${2-1}" ## Exit code specified by $2, or 1 by default.
      }

      main "$@" ; exit
